# Technical Debt & Implementation Notes

This document tracks technical decisions, implementations, and areas that may need future attention or refactoring.

---

## Phase 2.3: Agent Configuration Implementation

### Overview
Implemented a complete business-focused agent system for Radd Assistant with 5 specialized modes, memory bank functionality, and comprehensive configuration system.

---

## 1. Business Modes System

### What Was Created

**File:** `kilocode/src/shared/business-modes.ts`

A new mode system specifically designed for business users, separate from the developer-focused default modes.

### 5 Business Modes

1. **Ask Mode (پرسش و پاسخ)**
   - Purpose: Q&A and document analysis
   - Tools: Read-only (read, browser, mcp)
   - Use case: Answering questions, summarizing documents
   - Restrictions: Cannot modify files

2. **Analyst Mode (تحلیلگر)**
   - Purpose: Data analysis and business insights
   - Tools: Read + limited edit (.md, .txt, .csv only)
   - Use case: Financial analysis, trend identification
   - Restrictions: Can only edit text and data files

3. **Researcher Mode (پژوهشگر)**
   - Purpose: Web research and information gathering
   - Tools: Read + limited edit (.md, .txt only)
   - Use case: Market research, competitive analysis
   - Restrictions: Can only edit markdown and text files

4. **Planner Mode (برنامه‌ریز)**
   - Purpose: Project planning and task management
   - Tools: Read + limited edit (.md, .txt only)
   - Use case: Creating plans, managing tasks
   - Restrictions: Can only edit markdown and text files

5. **Writer Mode (نویسنده)**
   - Purpose: Content creation and document writing
   - Tools: Full access (read, edit, browser, mcp)
   - Use case: Writing reports, letters, presentations
   - Restrictions: None (full edit access)

### Key Design Decisions

#### English System Prompts, Persian UI
- **Decision:** System prompts (roleDefinition, customInstructions) are in English
- **Rationale:** LLMs perform significantly better with English prompts
- **Implementation:** UI labels (name, description, whenToUse) are in Persian for users
- **Impact:** Best of both worlds - optimal AI performance + localized UX

#### Tool Group Restrictions
- **Decision:** Use fileRegex restrictions on edit group
- **Rationale:** Prevent accidental modification of critical files
- **Implementation:** 
  ```typescript
  ["edit", { fileRegex: "\\.(md|txt|csv)$", description: "فقط فایل‌های متنی و گزارش" }]
  ```
- **Impact:** Safer modes for non-technical users

#### Mode-Specific Rules Files
- **Decision:** Create separate rules files for each mode
- **Rationale:** Fine-grained control over mode behavior
- **Location:** `kilocode/.kilocode/rules-{mode}/`
- **Impact:** Easier to maintain and customize per mode

### Integration Points

**Modified Files:**
- `kilocode/src/shared/modes.ts` - Integrated business modes with default modes
- Changed default mode from "code" to "ask"
- Merged BUSINESS_MODES with DEFAULT_MODES

**Deprecated:**
- `kilocode/src/shared/modes-fa.ts` - Old Persian modes with Persian system prompts
- Kept for backward compatibility but redirects to business-modes.ts

### Technical Debt

1. **No Runtime Testing Yet**
   - All modes defined but not tested in actual runtime
   - Need to verify tool restrictions work correctly
   - Need to test Persian UI labels display properly

2. **Mode Switching UX**
   - No UI for easily switching between modes yet
   - Users need to know mode names/slugs
   - Could benefit from mode recommendation system

3. **Mode Discovery**
   - No in-app documentation for when to use each mode
   - Could add interactive mode selector with examples

---

## 2. Memory Bank System

### What Was Created

**Files:**
- `kilocode/src/services/memory-bank/MemoryBankService.ts` - Core service
- `kilocode/src/services/memory-bank/index.ts` - Exports
- `kilocode/src/core/config/radd-defaults.ts` - Templates and defaults

### Purpose

The Memory Bank provides persistent project context that helps the AI assistant understand:
- What the project is about
- Key concepts and terminology
- Important files and their purposes
- Past decisions and their rationale
- Common workflows and processes

### How It Works

1. **Initialization**
   - Creates `.kilocode/memory-bank/` directory in workspace
   - Generates 5 template files with bilingual content
   - Creates README.md with instructions

2. **Template Files**

   **project-overview.md**
   - High-level project description
   - Main objectives
   - Stakeholders
   - Current status
   
   **key-concepts.md**
   - Domain-specific terminology
   - Important concepts
   - Abbreviations
   - Reference sources
   
   **important-files.md**
   - Folder structure explanation
   - Key files index
   - Periodic reports
   - Templates
   
   **decisions-log.md**
   - Decision tracking with context
   - Rationale for choices
   - Expected consequences
   - Template for new decisions
   
   **workflows.md**
   - Daily/weekly/monthly processes
   - Checklists
   - Process diagrams (Mermaid)

3. **Service API**

   ```typescript
   class MemoryBankService {
     // Check if memory bank exists
     async exists(): Promise<boolean>
     
     // Initialize with templates
     async initialize(): Promise<{success: boolean, message: string}>
     
     // Get list of memory files
     async getFiles(): Promise<string[]>
     
     // Read a specific file
     async readFile(filename: string): Promise<string | undefined>
     
     // Write to a file
     async writeFile(filename: string, content: string): Promise<boolean>
     
     // Get all content as single string for AI context
     async getAllContent(): Promise<string>
     
     // Get available templates
     getTemplates(): MemoryBankTemplate[]
     
     // Add file from template
     async addFromTemplate(templateFilename: string): Promise<boolean>
   }
   ```

### Integration Status

**Created but NOT Integrated:**
- Service exists but is not called from extension.ts
- No UI for initializing memory bank
- No automatic loading into AI context
- No commands registered for memory bank management

### Technical Debt

1. **Not Integrated into Extension**
   - Service created but not wired up to extension lifecycle
   - Need to add commands:
     - `radd-assistant.initializeMemoryBank`
     - `radd-assistant.openMemoryBank`
     - `radd-assistant.refreshMemoryBank`
   
2. **Not Loaded into AI Context**
   - Memory bank content not automatically included in system prompt
   - Need to integrate with `kilocode/src/core/prompts/system.ts`
   - Should load via `getAllContent()` and append to prompt

3. **No UI/UX**
   - No webview UI for managing memory bank
   - No status indicator showing if memory bank is active
   - No guided setup wizard

4. **No Validation**
   - Templates are just markdown - no schema validation
   - No checks for required sections
   - No warnings if memory bank is empty/outdated

5. **Performance Concerns**
   - `getAllContent()` loads all files into memory
   - Could be slow with large memory banks
   - No caching mechanism
   - No incremental loading

### Recommended Next Steps

1. **Immediate (Phase 2.4):**
   - Register commands in package.json
   - Wire up service in extension.ts
   - Add to system prompt generation

2. **Phase 3 (Polish):**
   - Create webview UI for memory bank
   - Add initialization wizard
   - Add status indicators

3. **Post-MVP:**
   - Add validation and schema
   - Implement caching
   - Add auto-update suggestions
   - Add memory bank templates marketplace

---

## 3. Default Settings System

### What Was Created

**File:** `kilocode/src/core/config/radd-defaults.ts`

### Purpose

Centralized configuration for Radd-specific defaults, separate from Kilo Code defaults.

### Contents

1. **RaddDefaultSettings Interface**
   ```typescript
   {
     defaultMode: "ask",           // Start with Q&A mode
     language: "fa",               // Persian by default
     showTerminal: false,          // Hide terminal for business users
     autoCheckpoint: true,         // Auto-save via shadow git
     memoryBankEnabled: true,      // Enable memory bank
     defaultProvider: "openai"     // Default AI provider
   }
   ```

2. **Memory Bank Templates**
   - 5 template definitions with bilingual content
   - Each has: filename, title, titlePersian, description, template

3. **Mode API Suggestions**
   - Recommended AI models per mode
   - Example: "ask" → gpt-4o-mini (fast, cheap)
   - Example: "writer" → claude-3-5-sonnet (better writing)

### Integration Status

**Created but NOT Applied:**
- Defaults defined but not used anywhere
- No code reads from RADD_DEFAULTS
- No settings UI uses these values
- No initialization code applies these defaults

### Technical Debt

1. **Not Applied on First Run**
   - Defaults exist but aren't set when extension first activates
   - Need to check if first run and apply defaults
   - Should merge with existing settings, not overwrite

2. **No Settings Migration**
   - If user has Kilo Code settings, they won't get Radd defaults
   - Need migration logic to apply Radd-specific defaults

3. **Mode API Suggestions Not Used**
   - MODE_API_SUGGESTIONS defined but not referenced
   - Could show these suggestions in mode selector
   - Could auto-switch API config when switching modes

4. **No Validation**
   - No schema validation for settings
   - No type checking at runtime
   - Could use Zod schema like modes do

### Recommended Next Steps

1. **Immediate:**
   - Add first-run detection in extension.ts
   - Apply RADD_DEFAULTS on first activation
   - Store flag in globalState to prevent re-applying

2. **Phase 3:**
   - Create settings UI that uses these defaults
   - Show mode API suggestions in UI
   - Add settings import/export

---

## 4. Mode-Specific Rules Files

### What Was Created

**Location:** `kilocode/.kilocode/rules-{mode}/`

5 comprehensive rules files, one per business mode:
- `rules-ask/business-qa.md`
- `rules-analyst/business-analysis.md`
- `rules-researcher/research-guidelines.md`
- `rules-planner/planning-guidelines.md`
- `rules-writer/writing-guidelines.md`

### Purpose

Provide detailed, mode-specific instructions that are automatically loaded when that mode is active.

### How It Works (Existing Kilo Code Feature)

1. When mode is selected, system checks for `.kilocode/rules-{mode}/` directory
2. All markdown files in that directory are loaded
3. Content is appended to system prompt under "Mode-specific Instructions"
4. This happens automatically via `addCustomInstructions()` in `custom-instructions.ts`

### Content Structure

Each rules file includes:
- Purpose statement
- Core behaviors
- Language guidelines (Persian for responses)
- Specific workflows/structures
- Examples and templates
- Quality standards
- File editing restrictions

### Integration Status

**Fully Integrated:**
- Rules files are in correct location
- Will be automatically loaded by existing Kilo Code infrastructure
- No additional code needed

### Technical Debt

1. **Not Tested**
   - Haven't verified rules are actually loaded
   - Haven't tested if they affect AI behavior as expected
   - Need runtime testing with actual AI calls

2. **Could Be More Structured**
   - Currently just markdown files
   - Could use YAML frontmatter for metadata
   - Could have machine-readable sections

3. **No Validation**
   - No checks if rules file is well-formed
   - No warnings if rules conflict with mode definition
   - No linting for rules content

4. **Duplication with Mode customInstructions**
   - Mode definitions have customInstructions
   - Rules files have similar content
   - Could consolidate or clarify separation of concerns

### Recommended Approach

**Keep as-is for MVP:**
- Rules files provide detailed, editable guidelines
- Mode customInstructions provide core behavior
- Separation allows users to customize rules without modifying code

**Post-MVP:**
- Add rules file editor in UI
- Add validation and linting
- Add rules templates marketplace

---

## 5. Custom Modes Configuration

### What Was Created

**File:** `kilocode/.kilocodemodes`

A template YAML file for defining custom modes at the project level.

### Purpose

Allow users to create project-specific modes without modifying code.

### How It Works (Existing Kilo Code Feature)

1. File is read by `CustomModesManager.ts`
2. Modes defined here override built-in modes
3. Can define new modes or override existing ones
4. Supports all mode configuration options

### Integration Status

**Fully Integrated:**
- Uses existing Kilo Code infrastructure
- File format is standard
- Will be automatically loaded

### Technical Debt

1. **Just a Template**
   - File is empty (just comments)
   - No actual custom modes defined
   - Users need to know YAML syntax

2. **No Documentation**
   - No guide on how to create custom modes
   - No examples of real custom modes
   - No validation feedback

3. **No UI**
   - Must edit YAML manually
   - No visual mode builder
   - No syntax highlighting for mode definitions

### Recommended Next Steps

**Phase 3:**
- Add example custom mode in comments
- Create documentation for custom modes

**Post-MVP:**
- Build visual mode builder UI
- Add mode validation and preview
- Add mode sharing/marketplace

---

## 6. Deprecated Code

### modes-fa.ts

**Status:** Deprecated but kept for backward compatibility

**Original Purpose:**
- Defined Persian business modes with Persian system prompts

**Why Deprecated:**
- LLMs perform better with English prompts
- New business-modes.ts uses English prompts + Persian UI

**Current State:**
- File redirects to business-modes.ts
- Exports are re-exported for compatibility
- Should be removed in v2.0

**Technical Debt:**
- Adds confusion (two files for modes)
- Could break if someone imports directly
- Should add deprecation warnings

---

## 7. Missing Integrations

### High Priority

1. **Memory Bank Service Not Wired Up**
   - Service exists but not called
   - Need to add to extension.ts activation
   - Need to add commands to package.json
   - Need to integrate with system prompt

2. **Default Settings Not Applied**
   - RADD_DEFAULTS defined but not used
   - Need first-run detection
   - Need to apply defaults on activation

3. **No Mode Initialization**
   - Business modes defined but not set as default
   - Need to ensure "ask" mode is selected on first run
   - Need to show mode selector on first use

### Medium Priority

4. **No Memory Bank UI**
   - No way to initialize from UI
   - No status indicator
   - No file browser for memory bank

5. **No Mode Switching UI**
   - Can switch modes but no visual selector
   - No mode descriptions in UI
   - No mode recommendations

6. **No Settings UI for Radd Defaults**
   - Can't configure Radd-specific settings
   - No UI for language preference
   - No UI for memory bank toggle

### Low Priority

7. **No Analytics/Telemetry**
   - Don't know which modes are used most
   - Don't know if memory bank is helpful
   - Can't measure user engagement

8. **No Onboarding Flow**
   - No first-run wizard
   - No mode introduction
   - No memory bank setup guide

---

## 8. Testing Gaps

### Unit Tests Needed

1. **MemoryBankService**
   - Test initialization
   - Test file reading/writing
   - Test getAllContent()
   - Test error handling

2. **Business Modes**
   - Test mode definitions are valid
   - Test tool restrictions work
   - Test fileRegex patterns

3. **Default Settings**
   - Test settings application
   - Test settings merging
   - Test migration logic

### Integration Tests Needed

1. **Mode Switching**
   - Test switching between modes
   - Test rules files are loaded
   - Test tool restrictions are enforced

2. **Memory Bank Integration**
   - Test memory bank content in prompts
   - Test memory bank updates
   - Test memory bank persistence

3. **End-to-End**
   - Test complete user flow
   - Test with actual AI calls
   - Test Persian language handling

---

## 9. Performance Considerations

### Current Issues

1. **Memory Bank Loading**
   - Loads all files on every request
   - No caching
   - Could be slow with large memory banks

2. **Mode Rules Loading**
   - Loads rules files on every prompt generation
   - No caching
   - Redundant file I/O

3. **No Lazy Loading**
   - All modes loaded at startup
   - All templates loaded at startup
   - Could defer until needed

### Recommended Optimizations

1. **Add Caching**
   - Cache memory bank content
   - Invalidate on file changes
   - Use VS Code file watcher

2. **Lazy Load Modes**
   - Only load mode definitions when needed
   - Only load rules when mode is activated
   - Defer template loading

3. **Optimize File I/O**
   - Batch file reads
   - Use async/await properly
   - Add read-ahead for common files

---

## 10. Security Considerations

### Current State

1. **File Access**
   - Memory bank service can read/write any file in workspace
   - No validation of file paths
   - Could potentially access files outside workspace

2. **Mode Restrictions**
   - Tool restrictions defined but not tested
   - FileRestrictionError thrown but not caught
   - Could bypass restrictions with symlinks

3. **User Input**
   - No sanitization of memory bank content
   - No validation of custom mode definitions
   - Could inject malicious content into prompts

### Recommended Security Measures

1. **Path Validation**
   - Validate all file paths are within workspace
   - Resolve symlinks before checking
   - Reject paths with ".." or absolute paths

2. **Content Sanitization**
   - Sanitize memory bank content before adding to prompt
   - Validate custom mode YAML before loading
   - Limit file sizes

3. **Error Handling**
   - Catch FileRestrictionError and show user-friendly message
   - Log security violations
   - Add rate limiting for file operations

---

## 11. Documentation Gaps

### Missing Documentation

1. **Memory Bank**
   - No user guide for memory bank
   - No examples of good memory bank content
   - No best practices

2. **Business Modes**
   - No guide on when to use each mode
   - No examples of mode usage
   - No troubleshooting guide

3. **Custom Modes**
   - No tutorial for creating custom modes
   - No reference for mode configuration options
   - No examples of real custom modes

4. **API Documentation**
   - No JSDoc for MemoryBankService
   - No API reference for radd-defaults
   - No type documentation

### Recommended Documentation

**Phase 3:**
- User guide for memory bank (Persian)
- Mode selection guide (Persian)
- Quick start guide

**Post-MVP:**
- Developer guide for custom modes
- API reference
- Architecture documentation

---

## 12. Future Enhancements

### Short Term (Phase 3)

1. **Memory Bank UI**
   - Visual editor for memory bank files
   - Template selector
   - Status indicator

2. **Mode Selector UI**
   - Visual mode picker
   - Mode descriptions
   - Mode recommendations based on task

3. **Settings UI**
   - Radd-specific settings panel
   - Language selector
   - Provider configuration

### Medium Term (Post-MVP)

1. **Smart Memory Bank**
   - Auto-suggest memory bank updates
   - Extract key concepts from documents
   - Summarize decisions automatically

2. **Mode Marketplace**
   - Share custom modes
   - Download community modes
   - Rate and review modes

3. **Workflow Automation**
   - Chain modes together
   - Save common workflows
   - Schedule tasks

### Long Term (v2.0+)

1. **AI-Powered Mode Selection**
   - Automatically suggest best mode for task
   - Learn from user preferences
   - Adapt to user's workflow

2. **Collaborative Memory Bank**
   - Share memory bank across team
   - Sync via cloud
   - Version control for memory bank

3. **Advanced Analytics**
   - Track mode effectiveness
   - Measure memory bank impact
   - Optimize prompts based on usage

---

## Summary

### What Works
- ✅ Business modes defined with proper structure
- ✅ Mode-specific rules files in place
- ✅ Memory bank service implemented
- ✅ Default settings defined
- ✅ Integration with existing Kilo Code infrastructure

### What Needs Work
- ❌ Memory bank not integrated into extension
- ❌ Default settings not applied
- ❌ No UI for memory bank or mode selection
- ❌ No testing (unit or integration)
- ❌ No documentation for users

### Priority Order
1. **Critical:** Integrate memory bank into system prompt
2. **Critical:** Apply default settings on first run
3. **High:** Add commands for memory bank management
4. **High:** Test modes with actual AI calls
5. **Medium:** Create mode selector UI
6. **Medium:** Create memory bank UI
7. **Low:** Add analytics and telemetry

### Estimated Effort
- Integration work: 2-3 days
- UI work: 3-5 days
- Testing: 2-3 days
- Documentation: 1-2 days
- **Total: ~2 weeks** for complete implementation
